; constant
; ---------------------------------------------
arr . def 'emp'

def 'nl' [ pr '' ]

; condition
; ---------------------------------------------
def 'when' [(when-func cond)
	if when-func emp cond
]

def 'unless' [(unless-func cond)
	! cond . when unless-func
]

; list
; ---------------------------------------------
def '!' [(boolean)
	if false true boolean
]

def 'each' [(each-fun each-ls)
	null? each-ls . unless [
		car each-ls . each-fun
		cdr each-ls . each each-fun
	]
]

def 'fold' [(fold-fun fold-initial fold-ls)
	null? fold-ls . if fold-initial [
		let1 '_fold-res' [car fold-ls .0. fold-fun fold-initial] [
			cdr fold-ls . fold fold-fun _fold-res
		]
	]
]

def 'map' [(map-fun map-ls)
	fold [(x res)
		map-fun x .0. cons res
	] emp map-ls . rev
]

def 'rev' [(rev-ls)
	fold [(x res) cons x res] emp rev-ls
]

def 'len' [(len-ls)
	fold [(x res)
		++ res
	] 0 len-ls
]

def 'ref' [(num ls)
	= num 0 . if [car ls] [
		- num 1 . def '_tmp'
		cdr ls . ref _tmp
	]
]

; arithmetic
; ---------------------------------------------
def '++' [+ _ 1]

def '--' [- _ 1]

; temporary
; ---------------------------------------------
def 'let1' [(let1-key let1-value let1-fun)
	fun? let1-value . if [let1-value] let1-value . def let1-key
	let1-fun
]

; loop
; ---------------------------------------------
def 'for' [(initial-val last-val change-fun for-fun)
	= initial-val last-val . unless [
		for-fun initial-val
                change-fun initial-val .0. for last-val change-fun for-fun
	]
]


; regexp
; ---------------------------------------------
def 'match' [(match-base match-reg-str)
	string->regexp match-reg-str . this match-base
]

; logical operator
; ---------------------------------------------
def 'logical-and' [(b1 b2)
	if [ if true false b2 ] false b1
]

def 'logical-or' [(b1 b2)
	if true [ if true false b2 ] b1
]

def 'and' [(*and-conds)
	fold [(and-x and-res)
		fun? and-x . if [
			; function
			and-x . logical-and and-res
		] [
			; value
			logical-and and-x and-res
		]
	] true and-conds
]

def 'or' [(*or-conds)
	fold [(or-x or-res)
		fun? or-x . if [
			; function
			or-x . logical-or or-res
		] [
			; value
			logical-or or-x or-res
		]
	] false or-conds
]
