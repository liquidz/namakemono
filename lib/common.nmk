; constant
; ---------------------------------------------
arr . def 'emp'

def 'nl' [ pr '' ]

; condition
; ---------------------------------------------
def 'when' [(when-func when-cond)
	if when-func emp when-cond
]

def 'unless' [(unless-func unless-cond)
	! unless-cond . when unless-func
]

def '!=' [(_x_ _y_)
	= _x_ _y_ . !
]

; list
; ---------------------------------------------
def '!' [(boolean)
	if false true boolean
]

def 'cadr' [(cadr-ls)
	cdr cadr-ls .car
]

def 'caddr' [(cadr-ls)
	cdr cadr-ls .cdr .car
]

def 'last' [(last-ls)
	rev last-ls . car
]

def 'each' [(each-fun each-ls)
	null? each-ls . unless [
		car each-ls . each-fun
		cdr each-ls . each each-fun
	]
]

def 'each-line' [(each-line-fun each-line-str)
	/ each-line-str "\n" . each each-line-fun
]

def 'fold' [(fold-fun fold-initial fold-ls)
	null? fold-ls . if fold-initial [
		let1 '_fold-res' [car fold-ls .0. fold-fun fold-initial] [
			cdr fold-ls . fold fold-fun _fold-res
		]
	]
]

def 'map' [(map-fun map-ls)
	fold [(x res)
		map-fun x .0. cons res
	] emp map-ls . rev
]

def 'rev' [(rev-ls)
	fold [(x res) cons x res] emp rev-ls
]

def 'len' [(len-ls)
	fold [(x res)
		++ res
	] 0 len-ls
]

def 'ref' [(ref-num ref-ls)
	= ref-num 0 . if [car ref-ls] [
		- ref-num 1 . def '_tmp'
		cdr ref-ls . ref _tmp
	]
]

def 'take' [(t-n t-ls)
	len t-ls .0. - t-n . = 0 . if t-ls [
		rev t-ls . cdr .rev . take t-n
	]
]

def 'drop' [(d-n d-ls)
	= d-n 0 . if d-ls [
		-- d-n . def '_tmp'
		cdr d-ls . drop _tmp
	]
]

; arithmetic
; ---------------------------------------------
def '++' [+ _ 1]

def '--' [- _ 1]

; temporary
; ---------------------------------------------
def 'let1' [(let1-key let1-value let1-fun)
	fun? let1-value . if [let1-value] let1-value . def let1-key
	let1-fun
]

def 'let' [(*let-args)
	len let-args .0. - 1 .1. for 0 ++ [(n)
		% n 2 . = 0 . if [
			; key
			ref n let-args . ldef '_tmp_let_key' 
		] [
			;value
			ref n let-args . ldef _tmp_let_key
		]
	]
	last let-args . do
]

; loop
; ---------------------------------------------
def 'for' [(initial-val last-val change-fun for-fun)
	= initial-val last-val . unless [
		for-fun initial-val
                change-fun initial-val .0. for last-val change-fun for-fun
	]
]


; regexp
; ---------------------------------------------
def 'match' [(match-base match-reg-str)
	string->regexp match-reg-str . this match-base
]

; logical operator
; ---------------------------------------------
def 'logical-and' [(b1 b2)
	if [ if true false b2 ] false b1
]

def 'logical-or' [(b1 b2)
	if true [ if true false b2 ] b1
]

def 'and' [(*and-conds)
	fold [(and-x and-res)
		fun? and-x . if [
			; function
			and-x . logical-and and-res
		] [
			; value
			logical-and and-x and-res
		]
	] true and-conds
]

def 'or' [(*or-conds)
	fold [(or-x or-res)
		fun? or-x . if [
			; function
			or-x . logical-or or-res
		] [
			; value
			logical-or or-x or-res
		]
	] false or-conds
]

; string
; ---------------------------------------------
def 'str-ref' [(sref-str sref-n)
	string->list sref-str . ref sref-n
]

def 'list->string' [(l-s-ls)
	fold [(x res)
		+ res x
	] "" l-s-ls
]

def 'substr' [(str s e)
	- e s . + 1 . def '_tmp'
	string->list str . drop s . take _tmp . list->string
]

; function
; ---------------------------------------------
def 'do' [(do-fn)
	fun? do-fn . when do-fn
]

def 'recv' [(*recv-args)
	let1 'recv-ls' [rev recv-args . cadr . do] [
		len recv-ls .1. for 0 ++ [(n)
			ref n recv-args . def '_key'
			ref n recv-ls . ldef _key
		]
		last recv-args . do
	]
]

; etc
; ---------------------------------------------
def 'call/cc' [(call/cc-fn)
	call/cc '_tmp_' call/cc-fn
]
